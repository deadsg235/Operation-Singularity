"use client";

import * as THREE from "three";
import { useFrame, useThree } from "@react-three/fiber";
import { useRef, useState, useEffect } from "react";

interface EnemyProps {
  position: [number, number, number];
  onHitPlayer: () => void;
  onDestroy: () => void;
  difficulty?: number;
}

export function AdvancedDrone({ position, onHitPlayer, onDestroy, difficulty = 1 }: EnemyProps) {
  const mesh = useRef<THREE.Mesh>(null);
  const { camera, scene } = useThree();
  const [health, setHealth] = useState(100 * difficulty);
  const [isDead, setIsDead] = useState(false);
  const [isAttacking, setIsAttacking] = useState(false);
  
  const bobOffset = useRef(Math.random() * Math.PI * 2);
  const attackCooldown = useRef(0);
  const lastPosition = useRef(new THREE.Vector3(...position));
  const aggroRange = 15 * difficulty;
  const attackRange = 2.5;
  const speed = 0.03 + (difficulty * 0.01);

  useFrame((state, delta) => {\n    if (!mesh.current || isDead) return;\n\n    const enemyPos = mesh.current.position;\n    const playerPos = camera.position;\n    const distance = enemyPos.distanceTo(playerPos);\n    \n    attackCooldown.current -= delta;\n\n    // AI State Machine\n    if (distance > aggroRange) {\n      // Patrol behavior\n      const patrolRadius = 3;\n      const time = state.clock.elapsedTime * 0.5;\n      enemyPos.x = lastPosition.current.x + Math.sin(time + bobOffset.current) * patrolRadius;\n      enemyPos.z = lastPosition.current.z + Math.cos(time + bobOffset.current) * patrolRadius;\n    } else if (distance > attackRange) {\n      // Chase behavior\n      const direction = new THREE.Vector3()\n        .subVectors(playerPos, enemyPos)\n        .normalize();\n      \n      // Add some evasive movement\n      const evasion = new THREE.Vector3(\n        Math.sin(state.clock.elapsedTime * 4) * 0.5,\n        0,\n        Math.cos(state.clock.elapsedTime * 3) * 0.5\n      );\n      \n      direction.add(evasion.multiplyScalar(0.3));\n      enemyPos.add(direction.multiplyScalar(speed));\n      \n      // Face the player\n      mesh.current.lookAt(playerPos.x, enemyPos.y, playerPos.z);\n      setIsAttacking(false);\n    } else {\n      // Attack behavior\n      setIsAttacking(true);\n      if (attackCooldown.current <= 0) {\n        attackCooldown.current = 1.0 / difficulty; // Faster attacks with higher difficulty\n        onHitPlayer();\n        \n        // Attack animation - lunge forward\n        const lungeDirection = new THREE.Vector3()\n          .subVectors(playerPos, enemyPos)\n          .normalize()\n          .multiplyScalar(0.5);\n        enemyPos.add(lungeDirection);\n      }\n    }\n\n    // Floating/bobbing movement\n    enemyPos.y = 1 + Math.sin(state.clock.elapsedTime * 4 + bobOffset.current) * 0.3;\n    \n    // Rotation for menacing effect\n    mesh.current.rotation.y += delta * 2;\n    mesh.current.rotation.x = Math.sin(state.clock.elapsedTime * 2) * 0.2;\n  });\n\n  const takeDamage = (damage: number) => {\n    const newHealth = health - damage;\n    setHealth(newHealth);\n    \n    // Flash red when hit\n    if (mesh.current) {\n      const material = mesh.current.material as THREE.MeshStandardMaterial;\n      material.emissive.setHex(0xff0000);\n      setTimeout(() => {\n        material.emissive.setHex(0x330000);\n      }, 100);\n    }\n    \n    if (newHealth <= 0 && !isDead) {\n      setIsDead(true);\n      onDestroy();\n      \n      // Death animation\n      if (mesh.current) {\n        const deathTween = () => {\n          let scale = 1;\n          const animate = () => {\n            scale -= 0.05;\n            if (mesh.current && scale > 0) {\n              mesh.current.scale.setScalar(scale);\n              mesh.current.rotation.x += 0.2;\n              mesh.current.rotation.z += 0.3;\n              requestAnimationFrame(animate);\n            } else if (mesh.current) {\n              scene.remove(mesh.current);\n            }\n          };\n          animate();\n        };\n        deathTween();\n      }\n    }\n  };\n\n  // Expose takeDamage method\n  useEffect(() => {\n    if (mesh.current) {\n      (mesh.current as any).takeDamage = takeDamage;\n    }\n  }, [health]);\n\n  if (isDead) return null;\n\n  const healthRatio = health / (100 * difficulty);\n  const baseColor = isAttacking ? 0xff0000 : 0xff0040;\n  const currentColor = new THREE.Color(baseColor).lerp(new THREE.Color(0x660000), 1 - healthRatio);\n\n  return (\n    <group>\n      <mesh ref={mesh} position={position} userData={{ enemy: true, health }} castShadow>\n        <boxGeometry args={[0.8, 0.6, 0.8]} />\n        <meshStandardMaterial \n          color={currentColor}\n          metalness={0.8} \n          roughness={0.2}\n          emissive={isAttacking ? \"#ff0000\" : \"#330000\"}\n          emissiveIntensity={isAttacking ? 0.5 : 0.2}\n        />\n      </mesh>\n      \n      {/* Glowing eyes */}\n      <mesh position={[position[0] - 0.2, position[1] + 0.1, position[2] + 0.4]}>\n        <sphereGeometry args={[0.05, 8, 8]} />\n        <meshBasicMaterial color=\"#ff0000\" />\n      </mesh>\n      <mesh position={[position[0] + 0.2, position[1] + 0.1, position[2] + 0.4]}>\n        <sphereGeometry args={[0.05, 8, 8]} />\n        <meshBasicMaterial color=\"#ff0000\" />\n      </mesh>\n      \n      {/* Health bar */}\n      {healthRatio < 1 && (\n        <group position={[position[0], position[1] + 0.8, position[2]]}>\n          <mesh>\n            <planeGeometry args={[0.8, 0.1]} />\n            <meshBasicMaterial color=\"#333333\" transparent opacity={0.8} />\n          </mesh>\n          <mesh position={[(-0.4 + (0.8 * healthRatio) / 2), 0, 0.001]}>\n            <planeGeometry args={[0.8 * healthRatio, 0.08]} />\n            <meshBasicMaterial color={healthRatio > 0.3 ? \"#ff0000\" : \"#ffff00\"} />\n          </mesh>\n        </group>\n      )}\n    </group>\n  );\n}